package main

/*
Go Awake - Prevents your system from sleeping
--------------------------------------------
This program is a Go implementation of a system tray utility that prevents
your system from sleeping and optionally keeps your display on.

USER CONFIGURATION:
You can change the default settings below to customize how the program behaves
when it starts. These settings will be applied every time the program launches.
*/

import (
	"fmt"
	"log"
	"os"
	"os/signal"
	"runtime"
	"strings"
	"syscall"
	"time"

	"github.com/getlantern/systray"
	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/registry"
)

// ------------------------------------------------------
// USER CONFIGURABLE SETTINGS - Change these as needed
// ------------------------------------------------------
// Set to true to keep the system awake (prevent sleep) by default
var DEFAULT_KEEP_AWAKE = true

// Set to true to keep the display on (prevent screen turning off) by default
var DEFAULT_DISPLAY_ON = false

// Set to true to add the app to Windows startup by default
var DEFAULT_STARTUP_ENABLED = true

// Default shutdown timer (0 for unlimited, or set a duration like 2*time.Hour)
// Examples:
// - time.Duration(0)      = unlimited (never quit)
// - 30*time.Minute        = quit after 30 minutes
// - 2*time.Hour           = quit after 2 hours
// - 24*time.Hour          = quit after 1 day
// - 7*24*time.Hour        = quit after 1 week
var DEFAULT_SHUTDOWN_TIMER = time.Duration(0)

//------------------------------------------------------
// END USER CONFIGURABLE SETTINGS
//------------------------------------------------------

// Windows API constants
const (
	ES_CONTINUOUS       uint32 = 0x80000000
	ES_SYSTEM_REQUIRED  uint32 = 0x00000001
	ES_DISPLAY_REQUIRED uint32 = 0x00000002
)

// Global state
var (
	isAwake        bool
	displayOn      bool
	startupEnabled bool
	shutdownTimer  *time.Timer
	shutdownTime   *time.Time
	exitCh         chan struct{}
	trayReady      chan struct{}
)

// Indicator constants
const (
	indicatorAwake      = "[●]"
	indicatorSleep      = "[○]"
	indicatorDisplayOn  = "[■]"
	indicatorDisplayOff = "[□]"
	indicatorStartupOn  = "[▲]"
	indicatorStartupOff = "[△]"
	indicatorArrow      = " -> "
	indicatorApp        = "[APP]"
	indicatorStatus     = "[STATUS]"
	indicatorChange     = "[CHG]"
)

func main() {
	// Initialize channels
	exitCh = make(chan struct{})
	trayReady = make(chan struct{})

	// Setup interrupt handling, but ignore SIGINT and SIGTERM to make the app harder to kill
	signalCh := make(chan os.Signal, 1)
	signal.Notify(signalCh, os.Interrupt, syscall.SIGTERM)
	go func() {
		for {
			sig := <-signalCh
			log.Printf("Received signal %v, ignoring to prevent shutdown.", sig)
			// Optionally, show a notification or log the attempt
		}
	}()

	// Initialize with default settings
	isAwake = false // Will be set to true when keepSystemAwake() is called
	displayOn = DEFAULT_DISPLAY_ON
	startupEnabled = DEFAULT_STARTUP_ENABLED

	// Sync startup state with registry
	syncStartupState()

	// Start the system tray
	go systray.Run(onReady, onExit)

	// Wait for the tray to be ready
	<-trayReady

	// Apply default shutdown timer if set
	if DEFAULT_SHUTDOWN_TIMER > 0 {
		setShutdownTimer("Default timer", DEFAULT_SHUTDOWN_TIMER)
	}

	// Keep the system awake initially if default is set to true
	if DEFAULT_KEEP_AWAKE {
		keepSystemAwake()
		// Wait for tray to be ready, then update tray title to reflect awake state
		go func() {
			<-trayReady
			// Use systray API to update menu title for system status
			systray.SetTitle("Keep Awake")
			// Optionally, trigger a custom update function if needed
			updateTrayTitle()
		}()
	}

	// Wait for exit signal
	<-exitCh
}

func onReady() {
	// Set the icon
	systray.SetIcon(createIcon())
	systray.SetTitle("Keep Awake")
	systray.SetTooltip("Keep Awake")

	// Add menu items
	mSystem := systray.AddMenuItem(fmt.Sprintf("System (current status: %s)", getSystemStatusText()), "Toggle system sleep prevention")
	mDisplay := systray.AddMenuItem(fmt.Sprintf("Display (current status: %s)", getDisplayStatusText()), "Toggle display sleep prevention")
	mStartup := systray.AddMenuItem(fmt.Sprintf("Startup (current status: %s)", getStartupStatusText()), "Toggle start with Windows")
	mTimer := systray.AddMenuItem(fmt.Sprintf("Timer (current: %s)", getTimerStatus()), "Set shutdown timer")

	// Create a slice of timer submenu items to preserve order
	timerOptions := getTimerOptions()
	timerMenuItems := make([]*systray.MenuItem, len(timerOptions))

	// Add timer submenu items in order
	for i, opt := range timerOptions {
		timerMenuItems[i] = mTimer.AddSubMenuItem(opt.Name, "Set timer duration")
	}

	// Add separator and quit menu
	systray.AddSeparator()
	mQuit := systray.AddMenuItem("Quit this software", "Exit the application")

	// 如果默认需要保持唤醒，初始化后立即设置状态并刷新菜单
	if DEFAULT_KEEP_AWAKE && !isAwake {
		keepSystemAwake()
		mSystem.SetTitle(fmt.Sprintf("System (current status: %s)", getSystemStatusText()))
		updateTrayTitle()
	}

	// Signal that tray is ready
	close(trayReady)

	// Update UI
	updateTrayTitle()

	// Print startup message
	fmt.Printf("%s Started in system tray. Right-click for options.\n", indicatorApp)
	startupStatus := indicatorStartupOn
	if !startupEnabled {
		startupStatus = indicatorStartupOff
	}
	displayStatus := indicatorDisplayOff
	if displayOn {
		displayStatus = indicatorDisplayOn
	}
	fmt.Printf("%s Default: System %s + Display %s + Startup %s + Timer %s\n",
		indicatorStatus, indicatorAwake, displayStatus, startupStatus, getTimerStatus())

	// Process main menu clicks
	go func() {
		for {
			select {
			case <-mSystem.ClickedCh:
				toggleAwake()
				mSystem.SetTitle(fmt.Sprintf("System (current status: %s)", getSystemStatusText()))
				updateTrayTitle()

			case <-mDisplay.ClickedCh:
				toggleDisplay()
				mDisplay.SetTitle(fmt.Sprintf("Display (current status: %s)", getDisplayStatusText()))
				updateTrayTitle()

			case <-mStartup.ClickedCh:
				toggleStartup()
				mStartup.SetTitle(fmt.Sprintf("Startup (current status: %s)", getStartupStatusText()))
				updateTrayTitle()

			case <-mQuit.ClickedCh:
				cleanup()
				systray.Quit()
				return
			}
		}
	}()

	// Process timer submenu clicks in a separate goroutine
	go func() {
		for i, opt := range timerOptions {
			go func(idx int, option TimerOption) {
				for {
					<-timerMenuItems[idx].ClickedCh
					fmt.Printf("[DEBUG] Timer menu clicked: %s (%v)\n", option.Name, option.Duration)
					setShutdownTimer(option.Name, option.Duration)
					fmt.Printf("[DEBUG] Timer set: %s (%v)\n", option.Name, option.Duration)
					mTimer.SetTitle(fmt.Sprintf("Timer (current: %s)", getTimerStatus()))
					updateTrayTitle()
				}
			}(i, opt)
		}
	}()
}

func onExit() {
	// This is called when systray.Quit() is called
	close(exitCh)
}

func cleanup() {
	fmt.Printf("%s Quitting Keep Awake software...\n", indicatorSleep)

	// Cancel any active timer
	cancelShutdownTimer()

	// Restore normal power management
	restoreNormalPower()

	fmt.Println("Keep Awake software quit successfully")
}

func keepSystemAwake() {
	if isAwake {
		return
	}

	if runtime.GOOS == "windows" {
		flags := ES_CONTINUOUS | ES_SYSTEM_REQUIRED
		if displayOn {
			flags |= ES_DISPLAY_REQUIRED
		}

		ret, _, err := windows.NewLazySystemDLL("kernel32.dll").NewProc("SetThreadExecutionState").Call(uintptr(flags))
		if ret == 0 {
			log.Printf("Failed to set execution state: %v", err)
			return
		}

		displayStatus := indicatorDisplayOff
		if displayOn {
			displayStatus = indicatorDisplayOn
		}
		fmt.Printf("System %s + Display %s (Windows)\n", indicatorAwake, displayStatus)
		isAwake = true
	} else {
		log.Println("Unsupported OS:", runtime.GOOS)
	}
}

func restoreNormalPower() {
	if !isAwake {
		return
	}

	if runtime.GOOS == "windows" {
		ret, _, err := windows.NewLazySystemDLL("kernel32.dll").NewProc("SetThreadExecutionState").Call(uintptr(ES_CONTINUOUS))
		if ret == 0 {
			log.Printf("Failed to restore normal power state: %v", err)
			return
		}
		fmt.Printf("%s Normal power restored (Windows)\n", indicatorSleep)
	}

	isAwake = false
}

func toggleAwake() {
	if isAwake {
		restoreNormalPower()
		fmt.Printf("%s%s%s System SLEEP\n", indicatorAwake, indicatorArrow, indicatorSleep)
	} else {
		keepSystemAwake()
		fmt.Printf("%s%s%s System AWAKE\n", indicatorSleep, indicatorArrow, indicatorAwake)
	}
}

func toggleDisplay() {
	displayOn = !displayOn

	if isAwake {
		restoreNormalPower()
		keepSystemAwake()
	}

	status := indicatorDisplayOn
	if !displayOn {
		status = indicatorDisplayOff
	}
	fmt.Printf("%s Display %s\n", indicatorChange, status)
}

func toggleStartup() {
	if runtime.GOOS != "windows" {
		fmt.Println("Startup option is only available on Windows")
		return
	}

	startupEnabled = !startupEnabled

	if startupEnabled {
		if enableStartup() {
			status := indicatorStartupOn
			fmt.Printf("%s Startup %s - Application will start with Windows\n", indicatorChange, status)
		} else {
			startupEnabled = false // Revert on failure
			fmt.Println("Failed to enable startup")
		}
	} else {
		if disableStartup() {
			status := indicatorStartupOff
			fmt.Printf("%s Startup %s - Application will not start with Windows\n", indicatorChange, status)
		} else {
			startupEnabled = true // Revert on failure
			fmt.Println("Failed to disable startup")
		}
	}
}

func createIcon() []byte {
	// Simple 16x16 icon with a white circle
	return []byte{
		0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x10, 0x10, 0x00, 0x00, 0x01, 0x00,
		0x20, 0x00, 0x68, 0x04, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x28, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00,
		0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x9a, 0xff, 0xff,
		0xff, 0xdb, 0xff, 0xff, 0xff, 0xf6, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff,
		0xff, 0xf7, 0xff, 0xff, 0xff, 0xdb, 0xff, 0xff, 0xff, 0x9a, 0xff, 0xff,
		0xff, 0x3e, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x9a, 0xff, 0xff,
		0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0x9a, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0xdc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xdb, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x3e, 0xff, 0xff, 0xff, 0xf6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xf7, 0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x9a, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x9a, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0xdb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdb, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xfe, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0xdb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xdb, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x9a, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x9a, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0xf6, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xff, 0xff, 0xff, 0x3e, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x9a, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0x9a, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x3e, 0xff, 0xff, 0xff, 0x9a, 0xff, 0xff, 0xff, 0xdb, 0xff, 0xff,
		0xff, 0xf6, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff,
		0xff, 0xdb, 0xff, 0xff, 0xff, 0x9a, 0xff, 0xff, 0xff, 0x3e, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
		0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
	}
}

func getSystemStatusText() string {
	if isAwake {
		return fmt.Sprintf("%s AWAKE", indicatorAwake)
	}
	return fmt.Sprintf("%s SLEEP", indicatorSleep)
}

func getDisplayStatusText() string {
	if displayOn {
		return fmt.Sprintf("%s ON", indicatorDisplayOn)
	}
	return fmt.Sprintf("%s OFF", indicatorDisplayOff)
}

func getStartupStatusText() string {
	if startupEnabled {
		return fmt.Sprintf("%s ON", indicatorStartupOn)
	}
	return fmt.Sprintf("%s OFF", indicatorStartupOff)
}

func updateTrayTitle() {
	awakeStatus := fmt.Sprintf("%s AWAKE", indicatorAwake)
	if !isAwake {
		awakeStatus = fmt.Sprintf("%s SLEEP", indicatorSleep)
	}

	displayStatus := fmt.Sprintf("%s ON", indicatorDisplayOn)
	if !displayOn {
		displayStatus = fmt.Sprintf("%s OFF", indicatorDisplayOff)
	}

	startupStatus := fmt.Sprintf("%s ON", indicatorStartupOn)
	if !startupEnabled {
		startupStatus = fmt.Sprintf("%s OFF", indicatorStartupOff)
	}

	timerStatus := getTimerStatus()

	title := fmt.Sprintf("Keep Awake | %s | Display %s | Startup %s | Timer %s",
		awakeStatus, displayStatus, startupStatus, timerStatus)

	systray.SetTitle(title)
	systray.SetTooltip(title)
}

// Startup registry functions
func getStartupRegistryKey() (registry.Key, string) {
	return registry.CURRENT_USER, `Software\Microsoft\Windows\CurrentVersion\Run`
}

func isStartupEnabled() bool {
	if runtime.GOOS != "windows" {
		return false
	}

	k, path := getStartupRegistryKey()
	key, err := registry.OpenKey(k, path, registry.QUERY_VALUE)
	if err != nil {
		return false
	}
	defer key.Close()

	_, _, err = key.GetStringValue("KeepAwake")
	return err == nil
}

func enableStartup() bool {
	if runtime.GOOS != "windows" {
		return false
	}

	k, path := getStartupRegistryKey()
	key, err := registry.OpenKey(k, path, registry.SET_VALUE)
	if err != nil {
		fmt.Printf("Error opening registry key: %v\n", err)
		return false
	}
	defer key.Close()

	// Get the executable path
	exePath, err := os.Executable()
	if err != nil {
		fmt.Printf("Error getting executable path: %v\n", err)
		return false
	}

	err = key.SetStringValue("KeepAwake", exePath)
	if err != nil {
		fmt.Printf("Error setting registry value: %v\n", err)
		return false
	}

	return true
}

func disableStartup() bool {
	if runtime.GOOS != "windows" {
		return false
	}

	k, path := getStartupRegistryKey()
	key, err := registry.OpenKey(k, path, registry.SET_VALUE)
	if err != nil {
		fmt.Printf("Error opening registry key: %v\n", err)
		return false
	}
	defer key.Close()

	err = key.DeleteValue("KeepAwake")
	if err != nil && !strings.Contains(err.Error(), "The system cannot find the file specified") {
		fmt.Printf("Error deleting registry value: %v\n", err)
		return false
	}

	return true
}

func syncStartupState() {
	if runtime.GOOS == "windows" {
		// Set startup enabled from default setting
		startupEnabled = DEFAULT_STARTUP_ENABLED

		// Check actual registry state
		currentStartupEnabled := isStartupEnabled()

		// If this is first run and default is true, enable it
		if !currentStartupEnabled && startupEnabled {
			if enableStartup() {
				fmt.Println("Startup enabled by default on first run")
			} else {
				fmt.Println("Warning: Failed to enable startup on first run")
				startupEnabled = false
			}
		} else if currentStartupEnabled && !startupEnabled {
			// If startup is enabled in registry but default setting is false, disable it
			if disableStartup() {
				fmt.Println("Startup disabled by default on first run")
			} else {
				fmt.Println("Warning: Failed to disable startup on first run")
				startupEnabled = true
			}
		}

		// Update state to match registry
		startupEnabled = isStartupEnabled()
	} else {
		startupEnabled = false
	}
}

// ------------------------------------------------------
// TIMER OPTIONS - Add or remove timer options as needed
// ------------------------------------------------------
// Timer option struct to preserve order
type TimerOption struct {
	Name     string
	Duration time.Duration
}

func getTimerOptions() []TimerOption {
	return []TimerOption{
		{"Unlimited time (Default)", 0},
		{"5 seconds", 5 * time.Second},
		{"5 minutes", 5 * time.Minute},
		{"15 minutes", 15 * time.Minute},
		{"30 minutes", 30 * time.Minute},
		{"1 hour", 1 * time.Hour},
		{"2 hours", 2 * time.Hour},
		{"4 hours", 4 * time.Hour},
		{"8 hours", 8 * time.Hour},
		{"12 hours", 12 * time.Hour},
		{"1 day", 24 * time.Hour},
		{"2 days", 48 * time.Hour},
		{"1 week", 7 * 24 * time.Hour},
	}
}

func setShutdownTimer(durationName string, duration time.Duration) {
	// Cancel existing timer
	cancelShutdownTimer()

	fmt.Printf("[DEBUG] setShutdownTimer called with: %s (%v)\n", durationName, duration)

	if duration == 0 {
		fmt.Printf("%s Timer: Unlimited time (Never quit this software)\n", indicatorChange)
		return
	}

	// Calculate shutdown time
	t := time.Now().Add(duration)
	shutdownTime = &t

	// Create timer
	shutdownTimer = time.AfterFunc(duration, func() {
		fmt.Printf("%s Timer expired - quitting this software now\n", indicatorSleep)
		fmt.Printf("[DEBUG] Timer expired, calling cleanup and systray.Quit()\n")
		cleanup()
		systray.Quit()
	})

	// Format time for display
	var timeStr string
	switch {
	case duration.Seconds() < 60:
		timeStr = fmt.Sprintf("%.0f seconds", duration.Seconds())
	case duration.Minutes() < 60:
		timeStr = fmt.Sprintf("%.0f minutes", duration.Minutes())
	case duration.Hours() < 24:
		timeStr = fmt.Sprintf("%.0f hours", duration.Hours())
	default:
		timeStr = fmt.Sprintf("%.0f days", duration.Hours()/24)
	}

	shutdownTimeStr := shutdownTime.Format("2006-01-02 15:04:05")
	fmt.Printf("%s Timer: This software will quit in %s at %s\n", indicatorChange, timeStr, shutdownTimeStr)
	fmt.Printf("[DEBUG] Timer scheduled to quit in %s at %s\n", timeStr, shutdownTimeStr)
}

func cancelShutdownTimer() {
	if shutdownTimer != nil {
		shutdownTimer.Stop()
		shutdownTimer = nil
		shutdownTime = nil
		fmt.Printf("%s Timer cancelled\n", indicatorChange)
	}
}

func getTimerStatus() string {
	if shutdownTime == nil {
		return "Unlimited time"
	}

	remaining := time.Until(*shutdownTime)
	if remaining <= 0 {
		return "Expired"
	}

	totalSeconds := int(remaining.Seconds())
	if totalSeconds < 60 {
		return fmt.Sprintf("%ds", totalSeconds)
	} else if totalSeconds < 3600 {
		return fmt.Sprintf("%dm", totalSeconds/60)
	} else if totalSeconds < 86400 {
		hours := totalSeconds / 3600
		minutes := (totalSeconds % 3600) / 60
		return fmt.Sprintf("%dh %dm", hours, minutes)
	} else {
		days := totalSeconds / 86400
		hours := (totalSeconds % 86400) / 3600
		return fmt.Sprintf("%dd %dh", days, hours)
	}
}
